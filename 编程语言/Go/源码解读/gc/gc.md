### Golang gc

还有一个点就是  为什么会有gc？？？
gc 的存在 是因为 刚开始的语言 比如 c语言 可以在堆上开辟空间 没有回收 造成内存溢出   栈上的空间可以自己回收，一般都是一些函数方法  固定变量。 堆上的是需要程序员开辟空间申请，然后释放。

由于程序员手动释放不及时 造成内存问题，所以在高级语言中引入了gc的概念，比如 java python  golang  etc.

程序员在编写的代码的时候，申请一个变量，会去内存申请一个空间，内存是硬件是有上限的，取决于内存的大小，如果超过了限制，就会报错，所以就需要释放不需要的内存空间资源，才可以给其他程序申请使用。程序员可以手动申请资源，也要及时手动释放资源，这样才能避免内存泄漏和资源浪费。

但是这样显然是 比较繁琐的，程序比较大的时候，程序员往往会忘记释放资源，导致程序崩溃。再者说，开发人员主要注重功能的实现，而不是耗费时间在内存分配释放上。所以 新的 高级语言就实现了自动GC。省去了开发人员的时间。


### 垃圾回收是什么，GC 是什么？
GC的全称是garbage collection，中文名称垃圾回收，是.net中对内存管理的一种功能。垃圾回收器跟踪并回收托管内存中分配的对象，定期执行垃圾回收以回收分配给没有有效引用的对象的内存。当使用可用内存不能满足内存请求时，GC会自动进行。


### gc算法 的方式以下几种，

1.追踪式

2.引用计数  

3.标记清除法

4.复制收集方式

5.分代收回


优缺点：


介绍以上gc方式的过程。

1.引用计数。
引用计数 就是指，针对每一个对象，如果外部对这个对象引用了，则相应的引用计数就会增加，如果该对象的引用计数变为0，就回收该对象。（因为外部没有引用此对象，所以可以回收这个垃圾对象。）

优点：
1.容易实现。
2.成本低。
3.这种中断产生的时间短。

缺点：
1.最著名的缺点就是 如果对象中存在循环引用，就无法被回收，假如三个对象互相引用，但是没有从根部出发，已经可以回收垃圾了。但是引用计数却不为0，不能回收。
2. 引用计数 不适合在并行中使用，多个线程同时操作引用计数，会引起数值不一样的问题。从而导致内存错误，所以引用计数必须是才用独占方式，如果引用操作频繁，那么加锁等并发控制机制的开销是相当大的。

perl 和python 都才用这种GC机制。




术语：
1.垃圾:
所谓垃圾 garbage  就是需要回收的对象，编写程序的人，可以定义对象，不需要判断是否内存垃圾的问题，计算机是做不到的，因为程序中的变量 一般是直接引用 或者间接引用。如果一个变量，对象没有被引用，就被视为存活，与之相反，已经引用不到的被视为死亡，将这些对象找出来，然后标记为垃圾，进行回收，这就是gc 的本质。


// GC 的全程（garbage collection）.
golang 采用的是追踪式 

1.5版本之前 使用的 mark and sweep  标记清扫 
1.5 后面的版本 添加了 并发 标记清扫  三色标记清除法  缩短了stw 的时间

1.8版本 加入了 写屏障 和 读屏障，就是 混合写屏障


1.三色标记法存在的问题，


浮动垃圾：
假设E 已经被标记为 灰色 ，此时D E 已经断开引用，按常理来说 EFG 应该被回收，但是因为E 已经变为灰色，FG 会被继续遍历下去，结果就是 这些对象会继续存活，而不会被内存回收。

```
过程如下：
A        B  -->   C
                  |
D  ———>  E  -->   F    
         |
         G   


A         B  -->  C
                  |
D  ——×—>  E  -->  F
    
          G  

```


漏标-悬挂指针问题：
除了上面多标的问题，还有就是漏标问题。当 GC 线程已经遍历到 E 变成灰色，D变成黑色时，灰色 E 断开引用白色 G ，黑色 D 引用了白色 G。此时切回 GC 线程继续跑，因为 E 已经没有对 G 的引用了，所以不会将 G 放到灰色集合。尽管因为 D 重新引用了 G，但因为 D 已经是黑色了，不会再重新做遍历处理。
最终导致的结果是：G 会一直停留在白色集合中，最后被当作垃圾进行清除。这直接影响到了应用程序的正确性，是不可接受的，这也是 Go 需要在 GC 时解决的问题。

```




```


内存屏障
为了解决上面的悬挂指针问题，我们需要引入屏障技术来保障数据的一致性。

内存屏障，是一种屏障指令，它能使CPU或编译器对在该屏障指令之前和之后发出的内存操作强制执行排序约束，在内存屏障前执行的操作一定会先于内存屏障后执行的操作。

那么为了在标记算法中保证正确性，那么我们需要达成下面任意一个条件：



强三色不变性（strong tri-color invariant）：黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象；


弱三色不变性（weak tri-color invariant）：即便黑色对象指向白色对象，那么从灰色对象出发，总存在一条可以找到该白色对象的路径；

根据操作类型的不同，我们可以将内存屏障分成 Read barrier（读屏障）和 Write barrier（写屏障）两种，在 Go 中都是使用 Write barrier（写屏障），原因在《Uniprocessor Garbage Collection Techniques》也提到了




golang  三色标记法

灰白黑

黑色： 该对象已经被标记过了，且该对象下得属性也全部都被标记过了。（程序所需要的对象）

灰色：该对象已经被标记过了，但该对象下得属性没有被全部标记完，（GC 需要从此对象中寻找垃圾）

白色：没有被标记过的对象（垃圾对象）


同时，在GC的过程中所有新分配的对象都会立刻变为黑色，在内存分配的时候 go\src\runtime\malloc.go 的 mallocgc 函数中可以看到：
```
代码函数
// Allocate an object of size bytes.
// Small objects are allocated from the per-P cache's free lists.
// Large objects (> 32 kB) are allocated straight from the heap.
//分配一个字节大小的对象。
//小对象从per-P缓存的空闲列表中分配。
//大对象(> 32kb)直接从堆中分配。





```



mallocgc.go文件
```


// Allocate an object of size bytes.
// Small objects are allocated from the per-P cache's free lists.
// Large objects (> 32 kB) are allocated straight from the heap.

//分配一个大小为字节的对象。
//小对象从 per-P 缓存的空闲列表中分配。
//大对象 (> 32 kB) 直接从堆中分配

	if gcphase == _GCmarktermination {
		throw("mallocgc called with gcphase == _GCmarktermination")
	}

	if size == 0 {
		return unsafe.Pointer(&zerobase)
	}

   //gc的阶段   3个阶段 

	_GCoff             = iota // GC not running; sweeping in background, write barrier disabled
	_GCmark                   // GC marking roots and workbufs: allocate black, write barrier ENABLED
	_GCmarktermination        // GC mark termination: allocate black, P's help GC, write barrier ENABLED

//GC        没有运行；在后台清扫，禁用写屏障
_GCmark //GC 标记根和工作缓冲区：分配黑色，写屏障启用
_GCmarktermination //GC标记终止：分配黑，P的帮助GC，写屏障启用





```


位运算 补充
```
<< [ 左移 ]
1 << 2 == 4
输出 0100 ，相比右移更常见，移位后空缺的部分全部填0
>> [ 右移 ]
10 >> 2 == 2
输出 0010
x ^ y [ 异或 ]
10 ^ 2 == 8
操作的结果是如果某位不同则该位为1, 否则该位为0
x | y [ 或 ]
10 | 2 == 10
两个相应的二进位中只要有一个为1, 该位的结果值为1
x & y [ 与 ]
10 & 2 == 2
两个相应的二进位都为1, 该位的结果值才为1,否则为0
^x [ 取反 ]
^2 == -3
减1取反 补码
```


内存分析

堆栈

什么是栈，什么是堆？
这里的堆栈 不是 数据结构里面的堆栈，而是系统里的堆栈。
代表着内存中的一块区域。 堆（heap） 栈（stack）


堆栈 其实 就栈   只不过叫法 成为堆栈，堆和栈是两个不同的区域，因为cpu 在执行复杂的计算时，ALU 就是算术逻辑单元，复杂的计算，需要将值临时保存到一个地方，才能进行下一步计算，然后再使用临时保存的值，所以cpu 就加上了存放数字的模块寄存器，比如有AX  bx cx  等等解决了复杂计算分布计算的问题， 由于计算的超级复杂的时候，这些寄存器不够用，能不能做很多寄存器呢，答案是：不能。这会增加cpu的复杂性，以及成本。
需要的条件,1.读写速度要快。
就只能去寻找合适的选择，内存运行速度快，所以 在就内存中开辟了一个区域，用来保存临时的值，就是栈，俗称堆栈。


栈的特点  先进后出，后入先出。因为对计算的操作都是函数，函数是套娃调用，A调用B ，B调用C ---所以出来的时候 也要 倒着出来，专业术语 叫 函数跳转。函数不能无限调用，堆栈的大小是有限的，所谓的递归调用，程序就会崩溃。
如果一个函数一定要调用自己，一定要设置一个条件。

栈分为 栈底 和栈顶。  高地址  ---低地址。

出栈后 数据还在栈里，但是还没有删除，已经被标位垃圾了。 


用户态 ring3  内核态 ring0  




代码区  数据区  初始化区  栈区 堆区

静态变量都是存放在 静态栈区中的。
全局变量 存放在静态数据区。



ss 段寄存器  sp 偏移寄存器


 mov  ax 0123H
 push ax
 mov bx
 push bx
 pop ax
 pop bx

 1.进程，线程
 进程是指运行的程序，资源分配的基本单位，程序段，数据段，PCB(进程控制块)，构成了进程的实体，线程是程序调用的最小单位。




 golang 上的变量 哪些是在栈上 还是在堆上。


```
编写代码的时候，往往不知道变量到底分配到哪里去了。可能在栈上，也可能在堆上。


堆（Heap）：一般来讲是人为手动进行管理，手动申请、分配、释放。一般所涉及的内存大小并不定，一般会存放较大的对象。另外其分配相对慢，涉及到的指令动作也相对多
栈（Stack）：由编译器进行管理，自动申请、分配、释放。一般不会太大，我们常见的函数参数（不同平台允许存放的数量不同），局部变量等等都会存放在栈上

golang的堆栈分配是通过 Compiler 进行分析，GC 去管理的,通过分析是否逃逸，去分配内存空间。

1.逃逸是什么？

在编译程序优化理论中，逃逸分析是一种确定指针动态范围的方法，简单来说就是分析在程序的哪些地方可以访问到该指针

通俗地讲，逃逸分析就是确定一个变量要放堆上还是栈上，规则如下：

是否有在其他地方（非局部）被引用。只要有可能被引用了，那么它一定分配到堆上。否则分配到栈上
即使没有被外部引用，但对象过大，无法存放在栈区上。依然有可能分配到堆上
对此你可以理解为，逃逸分析是编译器用于决定变量分配到堆上还是栈上的一种行为。

2.在什么阶段确立逃逸？？？

在编译阶段确立逃逸，注意并不是在运行时。

3.为什么需要逃逸？？？？
这个问题我们可以反过来想，如果变量都分配到堆上了会出现什么事情？例如：

垃圾回收（GC）的压力不断增大
申请、分配、回收内存的系统开销增大（相对于栈）
动态分配产生一定量的内存碎片
其实总的来说，就是频繁申请、分配堆内存是有一定 “代价” 的。会影响应用程序运行的效率，间接影响到整体系统。因此 “按需分配” 最大限度的灵活利用资源，才是正确的治理之道。

4.怎么确定是否逃逸？？？
第一，通过编译器命令，就可以看到详细的逃逸分析过程。而指令集 -gcflags 用于将标识参数传递给 Go 编译器，涉及如下：

-m 会打印出逃逸分析的优化策略，实际上最多总共可以用 4 个 -m，但是信息量较大，一般用 1 个就可以了
-l 会禁用函数内联，在这里禁用掉 inline 能更好的观察逃逸情况，减少干扰

go build -gcflags '-m -l' main.go

反编译
go tool compile -S main.go

例如：
go build -gcflags '-m -l' main.go
# command-line-arguments
./main.go:10:54: &User literal escapes to heap

逃逸到堆上了
CALL 指令，发现其执行了 runtime.newobject 方法，也就是确实是分配到了堆上。这是为什么呢？

总结：
除此之外你还需要注意：
静态分配到栈上，性能一定比动态分配到堆上好
底层分配到堆，还是栈。实际上对你来说是透明的，不需要过度关心
每个 Go 版本的逃逸分析都会有所不同（会改变，会优化）

逃逸分析是什么？ 维基百科说明：

在编译程序优化理论中，逃逸分析是一种确定指针动态范围的方法——分析在程序的哪些地方可以访问到指针。它涉及到指针分析和形状分析。

将堆分配转化为栈分配。如果某个对象在子程序中被分配，并且指向该对象的指针永远不会逃逸，该对象就可以在分配在栈上，而不是在堆上。在有垃圾收集的语言中，这种优化可以降低垃圾收集器运行的频率。
同步消除。如果发现某个对象只能从一个线程可访问，那么在这个对象上的操作可以不需要同步。
分离对象或标量替换。如果某个对象的访问方式不要求该对象是一个连续的内存结构，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。
```


go语言中  make 和new 的区别

```
make()分配：内部函数 make(T, args) 的服务目的和 new(T) 不同。
它只生成切片，映射和程道，并返回一个初始化的（不是零）的，type T的，不是 *T 的值。

这种区分的原因是，这三种类型的数据结构必须在使用前初始化.
比如切片是一个三项的描述符，包含数据指针（数组内），长度，和容量；在这些项初始化前，切片为 nil 。

对于切片、映射和程道，make初始化内部数据结构，并准备要用的值。
记住 make() 只用于映射、切片和程道，不返回指针。要明确的得到指针用 new() 分配。

```

golang 内存对齐

```

什么是内存对齐？
为什么要对齐？
怎么对齐？
对齐有什么好处？
跟平台有关系吗？  64位  32 位

1.内存对齐的收益

1.提高代码的平台的兼容性
2.优化数据对内存的使用
3.避免一些内存不对齐带来的bug
4.有助于源码的阅读




```